---
title: Bitcoin Next.js Frontend
description: In this tutorial you will learn how to build a simple Next.js frontend application that let's you call omnichain contract on ZetaChain from Bitcoin using different browser wallet extensions.
---

## Prerequisites

- [XDEFI](https://xdefi.io/) wallet extension [installed in your
  browser](https://www.xdefi.io/article/create-wallet-new/)
- [Unisat](https://docs.unisat.io/) wallet extension
- Bitcoin Testnet wallet with some testnet BTC (use [one of the
  faucets](https://coinfaucet.eu/en/btc-testnet/) available)
- [Node.js](https://nodejs.org/en/) installed on your machine with `npm` or
  `yarn`
- Learn how to [Deposit and call ZetaChain's EVM contracts from
  Bitcoin](/developers/evm/bitcoin/).
- Learn how to [Deposit and call ZetaChain's EVM contracts from
  Bitcoin](/developers/evm/bitcoin/).
- Familiarity with [Next.js](https://nextjs.org/docs)

## Clone the Next.js Example Frontend

Clone the repository:

```
git clone https://github.com/zeta-chain/example-frontend
```

Install dependencies:

```
cd example-frontend;
npm i;
```

## Bitcoin Transactions page

Let's add a new page under app/btcintegration:

```tsx filename="page.tsx"
"use client";

import React, { useState } from "react";
import { isUndefined } from "lodash";
import Wallet, { AddressPurpose } from "sats-connect";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

import { createTransaction, signPsbt } from "./xverse-utils";

type Wallet = "XDefi" | "UniSat" | "XVerse";

interface ConnectedAddressData {
  address: string;
  pubKey: string;
}

const BtcIntegration = () => {
  const [contractAddress, setContractAddress] = useState("");
  const [message, setMessage] = useState("");
  const [amount, setAmount] = useState();
  const [selectedWallet, setSelectedWallet] = useState<Wallet>("XDefi");

  return (
    <div className="grid sm:grid-cols-3 gap-x-10 mt-12">
      <div className="sm:col-span-2 overflow-x-auto">
        <div className="flex items-center justify-start gap-2 mb-6">
          <h1 className="leading-10 text-2xl font-bold tracking-tight pl-4">BTC Integration</h1>
        </div>
        <div className="pl-10 px-3 flex flex-col gap-6">
          <div>
            <Label>Amount in satoshis</Label>
            <Input
              type="number"
              value={amount}
              onChange={(e) => {
                setAmount(e.target.value);
              }}
              placeholder="0"
            />
          </div>
          <div>
            <Label>Omnichain contract address</Label>
            <Input
              type="text"
              value={contractAddress}
              onChange={(e) => {
                setContractAddress(e.target.value);
              }}
              placeholder="0xc79EA..."
            />
          </div>
          <div>
            <Label>Contract call parameters</Label>
            <Input
              type="text"
              value={message}
              onChange={(e) => {
                setMessage(e.target.value);
              }}
              placeholder="0x3724C..."
            />
          </div>

          <div>
            <select
              onChange={(e) => {
                setSelectedWallet(e.target.value);
              }}
              className="block my-2"
            >
              <option value="XDefi">XDEFI</option>
              <option value="UniSat">Unisat</option>
              <option value="XVerse">Xverse</option>
            </select>
            <Button
              size="sm"
              className="mt-4"
              onClick={() => {
                sendTransaction();
              }}
            >
              Send transaction
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BtcIntegration;
```

This React page contains a simple form with three inputs:

- Amount - the amount of tBTC to send
- Contract - the address of the omnichain contract to call
- Params - the parameters to pass to the contract call
- Wallet Select - a dropdown with a list of available wallets
- Send transaction - a button that will call the `sendTransaction` function

## Send Transaction Handler

To call an omnichain contract from Bitcoin you need to send a token transfer
transaction to the ZetaChain's [TSS address](/reference/contracts) on Bitcoin
with a memo that conforms to [the required
format](/developers/evm/bitcoin).

The memo is composed of two parts:

- The first part is the contract address encoded as hex string (without the `0x`
  prefix). This is the address of the omnichain contract you want to call.
- The second part is the message encoded as hex string (without the `0x`
  prefix). This is the message you want to pass to the contract call.

For example, if the omnichain contract address is
`0xc79E6DC99C5928C5b08ae7a0f79412521996938e` and it expects to receive one
argument that happens to be an address
`0x3724C896Cdc958611873D81547A98565c8cb849d`, the memo passed to the wallet
would look like:

```
c79E6DC99C5928C5b08ae7a0f79412521996938e3724C896Cdc958611873D81547A98565c8cb849d
```

The list of TSS address is available in [the docs](/reference/network/contracts), for
the purposes of this tutorial we will use a hard-coded value.

Get the contract address and parameters from the form and ensure that the `0x`
prefix is removed.

The amount is passed in tBTC, so we need to multiply it by `1e8` to convert it
to satoshis.

```tsx filename="page.tsx"
const sendTransaction = async () => {
  const tss = "tb1qy9pqmk2pd9sv63g27jt8r657wy0d9ueeh0nqur";
  if (contractAddress.length !== 42) return alert("Not a valid contract address");
  if (isUndefined(amount) || isNaN(amount)) return alert("Amount must be a number");

  const params = {
    contract: contractAddress.slice(2),
    message: message.slice(2),
    amount,
    tss,
  };

  switch (selectedWallet) {
    case "XDefi":
      await callXDefi(params);
      break;
    case "UniSat":
      await callUniSat(params);
      break;
    case "XVerse":
      await callXverse(params);
      break;
  }
};
```

## Use XDEFI Wallet

XDEFI injects itself into the `window` object, so we can access it from the
`window.xfi` property. Use the `getAccounts` method to get the list of accounts
and use the first one.

For XDEFI to properly encode the memo, you need to prefix it with `hex::`.

```tsx filename="page.tsx"
const callXDefi = async (params) => {
  if (!window.xfi) return alert("XDEFI wallet not installed");
  const wallet = window.xfi;
  window.xfi.bitcoin.changeNetwork("testnet");
  const account = (await wallet?.bitcoin?.getAccounts())?.[0];
  if (!account) return alert("No account found");
  const tx = {
    method: "transfer",
    params: [
      {
        feeRate: 10,
        from: account,
        recipient: params.tss,
        amount: {
          amount: params.amount,
          decimals: 8,
        },
        memo: `hex::${params.contract}${params.message}`,
      },
    ],
  };
  window.xfi.bitcoin.request(tx, (err, res) => {
    if (err) {
      return alert(`Couldn't send transaction, ${JSON.stringify(err)}`);
    } else if (res) {
      return alert(`Broadcasted a transaction, ${JSON.stringify(res)}`);
    }
  });
};
```

Call the `request` method on the `window.xfi.bitcoin` object to send the
transaction.

Now that we have the `from` address (your Bitcoin address), `recipient` address
(ZetaChain's TSS address), `amount` and a properly formatted `memo`, call
`window.xfi.bitcoin.request` to create and broadcast a transaction.

Learn more about how to use XDEFI programmatically in the [XDEFI
docs](https://docs.xdefi.io/).

## Use Unisat Wallet

Unisat injects itself into the `window` object, so we can access it from the
`window.unisat` property. Use the `requestAccounts` method to get the list of
accounts.

Prepare the memo by concatenating the contract address and the message and
converting the resulting string to lower case.

Use `unisat.sendBitcoin()` to make a token transfer to the TSS address.

```tsx filename="page.tsx"
const callUniSat = async (params) => {
  if (!window.unisat) return alert("Unisat wallet not installed");
  try {
    await window.unisat.requestAccounts();
    const memos = [`${params.contract}${params.message}`.toLowerCase()];
    const tx = await window.unisat.sendBitcoin(params.tss, params.amount, {
      memos,
    });
    return alert(`Broadcasted a transaction: ${JSON.stringify(tx)}`);
  } catch (e) {
    return alert(`Couldn't send transaction, ${JSON.stringify(e)}`);
  }
};
```

## Use Xverse Wallet

For Xverse we will use the [sats-connect](https://docs.xverse.app/sats-connect) package. Xverse doesn't have an easy to use API for sending a memo like the above two wallets but we can [create and sign arbitrary PSBT's](https://docs.xverse.app/sats-connect/guides/creating-bitcoin-psbts) so we will do that.

First get the accounts using `Wallet.request("getAccounts",...)`. Then we need to create a transaction using `createTransaction()` and sign it using `signPsbt()`.

```tsx filename="page.tsx"
const callXverse = async (params) => {
  const response = await Wallet.request("getAccounts", {
    purposes: [AddressPurpose.Payment],
    message: "Test app wants to know your addresses!",
  });

  if (response.status == "success") {
    const result = await createTransaction(response.result[0].publicKey, response.result[0].address, params);

    await signPsbt(result, response.result[0].address);
  } else {
    alert("wallet connection failed");
  }
};
```

Create a file xverse-utils.ts under btcintegration/

```ts filename="xverse-utils.ts"
import { base64, hex } from "@scure/base";
import * as btc from "micro-btc-signer";
import Wallet, { RpcErrorCode } from "sats-connect";

const bitcoinTestnet = {
  bech32: "tb",
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};

async function fetchUtxo(address: string): Promise<any[]> {
  try {
    const response = await fetch(`https://mempool.space/testnet/api/address/${address}/utxo`);
    if (!response.ok) {
      throw new Error("Failed to fetch UTXO");
    }
    const utxos: any[] = await response.json();

    if (utxos.length === 0) {
      throw new Error("0 Balance");
    }
    return utxos;
  } catch (error) {
    console.error("Error fetching UTXO:", error);
    throw error;
  }
}

async function createTransaction(publickkey: string, senderAddress: string, params) {
  const publicKey = hex.decode(publickkey);

  const p2wpkh = btc.p2wpkh(publicKey, bitcoinTestnet);
  const p2sh = btc.p2sh(p2wpkh, bitcoinTestnet);

  const recipientAddress = "tb1qy9pqmk2pd9sv63g27jt8r657wy0d9ueeh0nqur";
  if (!senderAddress) {
    throw new Error("Error: no sender address");
  }
  if (!recipientAddress) {
    throw new Error("Error: no recipient address in ENV");
  }

  const output = await fetchUtxo(senderAddress);

  const tx = new btc.Transaction({
    allowUnknowOutput: true,
  });

  output.forEach((utxo) => {
    tx.addInput({
      txid: utxo.txid,
      index: utxo.vout,
      witnessUtxo: {
        script: p2sh.script,
        amount: BigInt(utxo.value),
      },
      witnessScript: p2sh.witnessScript,
      redeemScript: p2sh.redeemScript,
    });
  });

  const changeAddress = senderAddress;

  const memo = `${params.contract}${params.message}`.toLowerCase();

  const opReturn = btc.Script.encode(["RETURN", Buffer.from(memo, "utf8")]);

  tx.addOutput({
    script: opReturn,
    amount: BigInt(0),
  });
  tx.addOutputAddress(recipientAddress, BigInt(params.amount), bitcoinTestnet);
  tx.addOutputAddress(changeAddress, BigInt(800), bitcoinTestnet);

  const psbt = tx.toPSBT(0);

  const psbtB64 = base64.encode(psbt);

  return psbtB64;
}

async function signPsbt(psbtBase64: string, senderAddress: string) {
  // Get the PSBT Base64 from the input

  if (!psbtBase64) {
    alert("Please enter a valid PSBT Base64 string.");
    return;
  }

  try {
    const response = await Wallet.request("signPsbt", {
      psbt: psbtBase64,
      allowedSignHash: btc.SignatureHash.ALL,
      broadcast: true,
      signInputs: {
        [senderAddress]: [0],
      },
    });

    if (response.status === "success") {
      alert("PSBT signed successfully!");
    } else {
      if (response.error.code === RpcErrorCode.USER_REJECTION) {
        alert("Request canceled by user");
      } else {
        console.error("Error signing PSBT:", response.error);
        alert("Error signing PSBT: " + response.error.message);
      }
    }
  } catch (err) {
    console.error("Unexpected error:", err);
    alert("Error while signing");
  }
}

export { createTransaction, signPsbt };
```

The `createTransaction()` function takes in the sender address and public key and generates a transaction with the memo attached `const opReturn = btc.Script.encode(["RETURN", Buffer.from(memo, "utf8")])`. It returns a base64 encoded PSBT.

The `signPsbt()` function will get the wallet to sign the transaction using `Wallet.request()`. Setting `broadcast: true` will also broadcast the transaction.

## Send a Transaction

Run the Next.js server:

```
npm run dev
```

Open the page in your browser and fill in the form. You can test functionality
with your own contract address or follow one of the provided tutorials, for
example, the [Staking](/developers/tutorials/staking/) tutorial to
deploy a contract that you can call from Bitcoin.

Fill out the form and click the "Send transaction" button. You will be prompted
to confirm the transaction.

Once the transaction is confirmed, you will see the transaction hash in an alert
window. You can use a Bitcoin block explorer like
[Blockstream](https://blockstream.info/testnet/) to check the transaction
status.

Once the transaction is confirmed on Bitcoin, you can check the transaction
status on ZetaChain using the `cctx` command from the [Hardhat
template](https://github.com/zeta-chain/template).
