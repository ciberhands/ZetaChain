---
title: Swap
---

## Overview

In this tutorial you will write a cross-chain swap contract that allows users to
swap a native gas or ERC-20 token from one of the connected chains for a token
on another chain.

The swap process involves depositing a token from a connected chain to
ZetaChain, triggering a swap omnichain contract to swap between ZRC-20
representations of the tokens and then withdrawing the swapped token to the
recipient address on the destination chain.

## Set Up Your Environment

Clone the Hardhat contract template:

```
git clone https://github.com/zeta-chain/template
```

Install dependencies:

```
cd template

yarn
```

## Create the contract

Run the following command to create a new universal omnichain contract called
`Swap`.

```
npx hardhat omnichain Swap targetToken:address recipient
```

## Omnichain Contract

```solidity filename="contracts/Swap.sol" {6-7,12,18-21,29-65}
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "@zetachain/protocol-contracts/contracts/zevm/SystemContract.sol";
import "@zetachain/protocol-contracts/contracts/zevm/interfaces/zContract.sol";
import "@zetachain/toolkit/contracts/SwapHelperLib.sol";
import "@zetachain/toolkit/contracts/BytesHelperLib.sol";
import "@zetachain/toolkit/contracts/OnlySystem.sol";

contract Swap is zContract, OnlySystem {
    SystemContract public systemContract;
    uint256 constant BITCOIN = 18332;

    constructor(address systemContractAddress) {
        systemContract = SystemContract(systemContractAddress);
    }

    struct Params {
        address target;
        bytes to;
    }

    function onCrossChainCall(
        zContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
    ) external virtual override onlySystem(systemContract) {
        Params memory params = Params({target: address(0), to: bytes("")});

        if (context.chainID == BITCOIN) {
            params.target = BytesHelperLib.bytesToAddress(message, 0);
            params.to = abi.encodePacked(
                BytesHelperLib.bytesToAddress(message, 20)
            );
        } else {
            (address targetToken, bytes memory recipient) = abi.decode(
                message,
                (address, bytes)
            );
            params.target = targetToken;
            params.to = recipient;
        }

        (address gasZRC20, uint256 gasFee) = IZRC20(params.target)
            .withdrawGasFee();

        uint256 inputForGas = SwapHelperLib.swapTokensForExactTokens(
            systemContract,
            zrc20,
            gasFee,
            gasZRC20,
            amount
        );

        uint256 outputAmount = SwapHelperLib.swapExactTokensForTokens(
            systemContract,
            zrc20,
            amount - inputForGas,
            params.target,
            0
        );

        IZRC20(gasZRC20).approve(params.target, gasFee);
        IZRC20(params.target).withdraw(params.to, outputAmount);
    }
}
```

### Decoding the Message

Create a `Params` struct, which will hold two values:

- `address target`: target token ZRC-20 address.
- `bytes to`: recipient address on the destination chain. We're using `bytes`,
  because the recipient can be either on EVM (like Ethereum or BNB) or on
  Bitcoin.

First, decode the incoming `message` to get the parameter values. The message
might be encoded differently depending on the source chain. For example, on
Bitcoin there is a upper limit of 80 bytes, so you might want to encode the
message in the most efficient way possible. On EVM don't have this limit, so
it's fine to use `abi.encode` to encode the message.

Use `context.chainID` to determine the connected chain from which the contract
is called.

If it's Bitcoin, the first 20 bytes of the `message` are the `params.target`
encoded as an `address`. Use `bytesToAddress` helper method to get the target
token address. To get the recipient address, use the same helper method with an
offset of 20 bytes and then use `abi.encodePacked` to convert the address to
`bytes`.

If it's an EVM chain, use `abi.decode` to decode the `message` into the
`params.target` and `params.to`.

### Swapping for Gas Token

Next, get the gas fee and the gas coin address from the target token. The gas
coin is the token that will be used to pay for the gas on the destination chain.

Use the `SwapHelperLib.swapTokensForExactTokens` helper method to swap the
incoming token for the gas coin using the internal liquidity pools. The method
returns the amount of the incoming token that was used to pay for the gas.

### Swapping for Target Token

Next, swap the incoming amount minus the amount spent swapping for a gas fee for
the target token on the destination chain using the
`SwapHelperLib.swapExactTokensForTokens` helper method.

Finally, withdraw the tokens to the recipient address on the destination chain.

## Update the Interact Task

In the `interact` task generated for us by the contract template the recipient
is encoded as string. Our contract, however, expects the recipient to be encoded
as `bytes` to ensure that both EVM and Bitcoin addresses are supported.

To support both EVM and Bitcoin addresses, we need to check if the recipient is
a valid Bitcoin address. If it is, we need to encode it as `bytes` using
`utils.solidityPack`.

If it’s not a valid bech32 address, then we assume it's an EVM address and use
`args.recipient` as the value for the recipient.

Finally, update the `prepareData` function call to use the `bytes` type for the
recipient.

```ts filename="tasks/interact.ts" {1,6-22}
import bech32 from "bech32";

const main = async (args: any, hre: HardhatRuntimeEnvironment) => {
  const [signer] = await hre.ethers.getSigners();

  let recipient;
  try {
    if (bech32.decode(args.recipient)) {
      recipient = utils.solidityPack(["bytes"], [utils.toUtf8Bytes(args.recipient)]);
    }
  } catch (e) {
    recipient = args.recipient;
  }

  const data = prepareData(args.contract, ["address", "bytes"], [args.targetToken, recipient]);
  //...
};
```

## Create an Account and Request Tokens from the Faucet

Before proceeding with the next steps, make sure you have [created an account
and requested ZETA tokens](/developers/tutorials/hello#create-an-account) from
the faucet.

## Compile and Deploy the Contract

```
npx hardhat compile --force
```

```
npx hardhat deploy --network zeta_testnet
```

```
🔑 Using account: 0x2cD3D070aE1BD365909dD859d29F387AA96911e1

🚀 Successfully deployed contract on ZetaChain.
📜 Contract address: 0xf6CDd83AB44E4d947FE52c2637ee4A04F330328E
🌍 Explorer: https://athens3.explorer.zetachain.com/address/0xf6CDd83AB44E4d947FE52c2637ee4A04F330328E
```

## Swap Native Gas Tokens Between EVM Chains

Use the `interact` task to perform a cross-chain swap. In this example, we're
swapping native sETH from Sepolia for BNB on BNB chain. The contract will
deposit sETH to ZetaChain as ZRC-20, swap it for ZRC-20 BNB and then withdraw
native BNB to the BNB chain. To get the value of the `--target-token` find the
ZRC-20 contract address of the destination token in the [ZRC-20 section of the
docs](/developers/tokens/zrc20).

```
npx hardhat interact --contract 0x175DeE06ca605674e49F1FADfC6B399D6ab31726 --amount 0.3 --network sepolia_testnet --target-token 0xd97B1de3619ed2c6BEb3860147E30cA8A7dC9891 --recipient 0x4955a3F38ff86ae92A914445099caa8eA2B9bA32
```

```
🔑 Using account: 0x4955a3F38ff86ae92A914445099caa8eA2B9bA32

🚀 Successfully broadcasted a token transfer transaction on sepolia_testnet
network. 📝 Transaction hash:
0xc4b2bbd3b3090e14797463af1965a00318cc39a50fce53a5d5856d09fe67410d
```

Track your cross-chain transaction:

```
npx hardhat cctx
0xc4b2bbd3b3090e14797463af1965a00318cc39a50fce53a5d5856d09fe67410d
```

```
✓ CCTXs on ZetaChain found.

✓ 0xf6419c8d850314a436a3cfc7bc5cd487e29bad9c8fae0d8be9a913d622599980: 11155111 → 7001: OutboundMined (Remote omnich
ain contract call completed)
⠧ 0x5e533d781ddc9760784ba9c1887f77a80d3ca0d771ea41f02bc4d0a1c9412dc2: 7001 → 97: PendingOutbound (ZRC20 withdrawal
event setting to pending outbound directly)
```

## Swap ERC-20 Tokens Between EVM Chains

Now let's swap USDC from Sepolia to BNB on BNB chain. To send USDC specify the
ERC-20 token contract address (on Sepolia) in the `--token` parameter. You can
find the address of the token in the [ZRC-20 section of the
docs](/developers/tokens/zrc20).

```
npx hardhat interact --contract 0xf6CDd83AB44E4d947FE52c2637ee4A04F330328E --amount 5 --token 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238 --network sepolia_testnet --target-token 0xd97B1de3619ed2c6BEb3860147E30cA8A7dC9891 --recipient 0x4955a3F38ff86ae92A914445099caa8eA2B9bA32
```

```
🔑 Using account: 0x2cD3D070aE1BD365909dD859d29F387AA96911e1

🚀 Successfully broadcasted a token transfer transaction on sepolia_testnet network.
📝 Transaction hash: 0xce8832232639d29d40078e14d0a5b20c055123d6df1e1d39f90cfd130c33466d
```

```
npx hardhat cctx 0xce8832232639d29d40078e14d0a5b20c055123d6df1e1d39f90cfd130c33466d
```

```
✓ CCTXs on ZetaChain found.

✓ 0x1ae1436358ef755c1c782d0a249ae99e857b0aecb91dcd8da4a4e7171f5d9459: 11155111 → 7001: OutboundMined (Remote omnichain contract call completed)
✓ 0xbefe99d3e17d16fc88762f85b1becd1396b01956c04b5ec037abc2c63d821caa: 7001 → 97: OutboundMined (ZRC20 withdrawal event setting to pending outbound directly : Outbound succeeded, mined)
```

## Swap from Bitcoin

Use the `send-btc` task to send Bitcoin to the TSS address with a memo. The memo
should contain the following:

- Omnichain contract address on ZetaChain:
  `175DeE06ca605674e49F1FADfC6B399D6ab31726`
- Target token address: `05BA149A7bd6dC1F937fA9046A9e05C05f3b18b0`
- Recipient address: `4955a3F38ff86ae92A914445099caa8eA2B9bA32`

```
npx hardhat send-btc --amount 0.001 --memo 175DeE06ca605674e49F1FADfC6B399D6ab3172605BA149A7bd6dC1F937fA9046A9e05C05f3b18b04955a3F38ff86ae92A914445099caa8eA2B9bA32 --recipient tb1qy9pqmk2pd9sv63g27jt8r657wy0d9ueeh0nqur
```

```
npx hardhat cctx 29d6a0af11aa6164e83c17d9f129e4ec504d327fb94429732d95c16ddfcce999
```

## Source Code

You can find the source code for the example in this tutorial here:

https://github.com/zeta-chain/example-contracts/tree/main/omnichain/swap
